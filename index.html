<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>queue: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">queue
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">queue Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Выпускное задание</h2>
<p>На одном из занятий мы изучали пул потоков. Ключевым элементом этого шаблона была общая очередь, которая была доступна всем потокам. Потоки можно поделить на две группы - первая группа, которая могла писать в очередь, формируя таким образом задания для остальных, и вторая группа потоков, которая могла читать из этой очереди. В таком виде наше решение могло быть использовано только на одной машине. Наша задача позволить распределить потоки работающие с этой очередью на разные машины.</p>
<p>Можно сразу ввести новые понятия - то что создает задание в очереди, фактически пишет в очередь, называется продюсер, то что читает из очереди называется консьюмер. Фактически наша задача сводится к написанию сервера который будет обеспечивать по сети доступ к методам <code>push_back()</code> для продюсеров и <code>front() / pop()</code> для консьюмеров класса <code>std::queue</code>.</p>
<p>Поскольку разрабатывая внешний сервер полагаться на его бесперебойную работу мы не можем, нам необходимо иметь подстраховку в виде копии нашей очереди на диске. На первом этапе мы можем ограничиться очередью только в памяти, но всегда должны помнить, что должна быть альтернатива в виде дисковой копии.</p>
<p>Отдельностоящий сервер должен будет взаимодействовать с другими машинами для подключений продюсеров и консьюмеров. Для этого он будет сопровождаться клиентской библиотекой, которая будет брать на себя сетевое взаимодействие с сервером и иметь несколько основных методов, например подключение к серверу с выбором экземпляра очереди по имени, аналог метода push_back для продюсера, аналог метода pop для консьюмера, который может работать в синхронном блокирующем режиме так и в асинхронном, ну и конечно же метод завершения работы.</p>
<p>В одну и ту же очередь допускается запись нескольких разных продюсеров. Из одной и той же очереди могут читать разные консьюмеры. Очередь на сервере никогда не очищается. Исключением будет ситуация, когда заканчивается оперативная или дисковая память. В этой ситуации должны быть удалены самые старые записи, которые хранятся в очереди.</p>
<p>За хранение информации о последней обработанной записи отвечает клиентская сторона. При подключении к серверу должна быть передана специальная метка, по которой сервер поймёт начиная с какой позиции в очереди необходимо отдавать данные. С каждой возвращенной порцией данных сервер обязан вернуть новую метку, клиент обязан эту метку сохранить.</p>
<p>Поскольку нет возможности работать с типизированными данными в качестве типа хранения мы выбираем строку.</p>
<p>Когда и кем создаются очереди - можно рассмотреть вариант с автоматическим созданием в момент первого подключения консьюмера или продьюсера.</p>
<p>Очередь не очищается (мы сделаем нечто типа кафки, справедливо не для всех очередей), у нас есть физический рекурс диска, когда он будет подходить к концу, можно удалить самые старые данные, вне зависимости от того - обработали их или еще нет.</p>
<p>На диск писать можно сразу по получению данных, стараться делать это либо асинхронно либо отдельным потоком, чтобы скорость записи на диск не тормозила клиентов, скорее всего для этого потребуется внутренняя очередь на запись.</p>
<p>Функционал на получение списка очередей как и всех остальных функций можно расширять на свое усмотрение, часть из них совершенно точно могут помочь в диагностике и администрировании будущего сервера. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
