# Queue
## Выпускное задание
На одном из занятий мы изучали пул потоков. Ключевым элементом этого шаблона была общая очередь, которая была доступна всем потокам. Потоки можно поделить на две группы - первая группа, которая могла писать в очередь, формируя таким образом задания для остальных, и вторая группа потоков, которая могла читать из этой очереди. В таком виде наше решение могло быть использовано только на одной машине. Наша задача позволить распределить потоки работающие с этой очередью на разные машины.

Можно сразу ввести новые понятия - то что создает задание в очереди, фактически пишет в очередь, называется продюсер, то что читает из очереди называется консьюмер. Фактически наша задача сводится к написанию сервера который будет обеспечивать по сети доступ к методам  `push_back()` для продюсеров и `front() / pop()` для консьюмеров класса `std::queue`.

Поскольку разрабатывая внешний сервер полагаться на его бесперебойную работу мы не можем, нам необходимо иметь подстраховку в виде копии нашей очереди на диске. На первом этапе мы можем ограничиться очередью только в памяти, но всегда должны помнить, что должна быть альтернатива в виде дисковой копии.

Отдельностоящий сервер должен будет взаимодействовать с другими машинами для подключений продюсеров и консьюмеров. Для этого он будет сопровождаться клиентской библиотекой, которая будет брать на себя сетевое взаимодействие с сервером и иметь несколько основных методов, например подключение к серверу с выбором экземпляра очереди по имени, аналог метода push_back для продюсера, аналог метода pop для консьюмера, который может работать в синхронном блокирующем режиме так и в асинхронном, ну и конечно же метод завершения работы.

В одну и ту же очередь допускается запись нескольких разных продюсеров. Из одной и той же очереди могут читать разные консьюмеры. Очередь на сервере никогда не очищается. Исключением будет ситуация, когда заканчивается оперативная или дисковая память. В этой ситуации должны быть удалены самые старые записи, которые хранятся в очереди.

За хранение информации о последней обработанной записи отвечает клиентская сторона. При подключении к серверу должна быть передана специальная метка, по которой сервер поймёт начиная с какой позиции в очереди необходимо отдавать данные. С каждой возвращенной порцией данных сервер обязан вернуть новую метку, клиент обязан эту метку сохранить.

Поскольку нет возможности работать с типизированными данными в качестве типа хранения мы выбираем строку.